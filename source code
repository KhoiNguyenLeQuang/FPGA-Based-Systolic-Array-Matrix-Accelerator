`timescale 1ns / 1ps

// MODULE 1: PROCESSING ELEMENT (PE)
module pe #(
    parameter WIDTH = 8,
    parameter ACC_WIDTH = 32
)(
    input wire clk, rst,
    input wire [WIDTH-1:0] a_in, b_in,
    output reg [WIDTH-1:0] a_out, b_out,
    output reg [ACC_WIDTH-1:0] c_out
);
    always @(posedge clk) begin
        if (rst) begin
            a_out <= 0; b_out <= 0; c_out <= 0;
        end else begin
            c_out <= c_out + (a_in * b_in);       
            a_out <= a_in;
            b_out <= b_in;
        end
    end
endmodule

// MODULE 2: SYSTOLIC ARRAY NxN
module systolic_array_NxN #(
    parameter N = 4,           
    parameter WIDTH = 8,
    parameter ACC_WIDTH = 32
)(
    input wire clk, rst,
    input wire [N*WIDTH-1:0] a_in_bus, 
    input wire [N*WIDTH-1:0] b_in_bus,
    output wire [N*N*ACC_WIDTH-1:0] c_out_bus
);
    wire [WIDTH-1:0] h_wire [0:N-1][0:N]; 
    wire [WIDTH-1:0] v_wire [0:N][0:N-1];
    
    genvar i, j;
    generate
        for (i = 0; i < N; i = i + 1) begin : ROWS
            for (j = 0; j < N; j = j + 1) begin : COLS
                
                if (j == 0) begin
                    assign h_wire[i][0] = a_in_bus[(i*WIDTH) +: WIDTH];
                end
                
                if (i == 0) begin
                    assign v_wire[0][j] = b_in_bus[(j*WIDTH) +: WIDTH];
                end
                
                 pe #(.WIDTH(WIDTH), .ACC_WIDTH(ACC_WIDTH)) pe_inst (
                    .clk(clk), .rst(rst),
                    .a_in(h_wire[i][j]),     
                    .b_in(v_wire[i][j]),     
                    .a_out(h_wire[i][j+1]),   
                    .b_out(v_wire[i+1][j]),
                    .c_out(c_out_bus[(i*N+j)*ACC_WIDTH +: ACC_WIDTH]) 
                );
            end
        end
    endgenerate
endmodule

// MODULE 3: TOP-LEVEL SYSTEM MODULE
module matrix_system_top(
    input wire sys_clk,
    input wire sys_rst_btn,
    input wire uart_rx_pin,
    output wire done_led,
    output wire [3:0] debug_led
);

    // PARAMETERS
    parameter N = 4;
    parameter WIDTH = 8;
    parameter ACC_WIDTH = 32;
    parameter MATRIX_SIZE = N * N; // 16 elements

    wire rst = sys_rst_btn;

    // UART RECEIVER
    wire [7:0] rx_byte;
    wire rx_dv;
    
    uart_rx #(.CLKS_PER_BIT(868)) rx_inst (
        .i_Clock(sys_clk),
        .i_Rx_Serial(uart_rx_pin),
        .o_Rx_DV(rx_dv),
        .o_Rx_Byte(rx_byte)
    );

    // INPUT BUFFERS
    reg [WIDTH-1:0] mem_A [0:MATRIX_SIZE-1];
    reg [WIDTH-1:0] mem_B [0:MATRIX_SIZE-1];
    
    // Counters to track loading
    reg [4:0] load_idx;       // 0 to 31 (tracks which byte we are receiving)
    reg loading_complete;     // Flag when both matrices are full

    // STATE MACHINE FOR LOADING
    always @(posedge sys_clk) begin
        if (rst) begin
            load_idx <= 0;
            loading_complete <= 0;
        end else if (rx_dv) begin
            // First 16 bytes go to Matrix A
            if (load_idx < MATRIX_SIZE) begin
                mem_A[load_idx] <= rx_byte;
                load_idx <= load_idx + 1;
            end 
            // Next 16 bytes go to Matrix B
            else if (load_idx < 2*MATRIX_SIZE) begin
                mem_B[load_idx - MATRIX_SIZE] <= rx_byte;
                load_idx <= load_idx + 1;
            end
            
            // Check if full
            if (load_idx == (2*MATRIX_SIZE - 1)) begin
                loading_complete <= 1;
            end
        end
    end

    // SYSTOLIC FEEDER LOGIC
    
    reg [5:0] compute_cycle; 
    reg [N*WIDTH-1:0] a_drive;
    reg [N*WIDTH-1:0] b_drive;
    
    integer i;

    always @(posedge sys_clk) begin
        if (rst) begin
            compute_cycle <= 0;
            a_drive <= 0;
            b_drive <= 0;
        end else if (loading_complete) begin
            // Run the counter
            if (compute_cycle < 20) compute_cycle <= compute_cycle + 1;

            // FEEDING LOGIC:           
            if (compute_cycle < N) begin
                for (i = 0; i < N; i = i + 1) begin
                    // Feed Row i of Matrix A
                    a_drive[(i*WIDTH) +: WIDTH] <= mem_A[i*N + compute_cycle];
                    // Feed Col i of Matrix B
                    b_drive[(i*WIDTH) +: WIDTH] <= mem_B[compute_cycle*N + i];
                end
            end else begin
                // Stop driving after N cycles (inputs become 0)
                a_drive <= 0;
                b_drive <= 0;
            end
        end
    end

    // INSTANTIATE SYSTOLIC ARRAY
    wire [N*N*ACC_WIDTH-1:0] result_bus;
    
    systolic_array_NxN #(.N(N), .WIDTH(WIDTH), .ACC_WIDTH(ACC_WIDTH)) core (
        .clk(sys_clk),
        .rst(rst),
        .a_in_bus(a_drive),
        .b_in_bus(b_drive),
        .c_out_bus(result_bus)
    );

    // --- OUTPUTS ---
    // Turn on LED when loading is done
    assign done_led = loading_complete; 
    
    // Debug: Show the bottom-right result bits on LEDs
    assign debug_led = result_bus[3:0];

endmodule
